### 使用C++实现一个矩形类根据矩形左下角和右上角两个坐标求出面积

##### **题目：**

调试下列程序，写出输出结果，并分析输出结果。

```c++
//Point.h文件
#ifndef POINT_H
#define POINT_H
class Point
{
	private:
		float x,y;
	public:
		Point();
		Point(int xx,int yy);
		Point(const Point &p); 
		float getX();
		float getY(); 
};
#endif
//Point.cpp文件
#include <iostream>
#include "Point.h"
using namespace std; 
Point::Point()
{
	x=0;
	y=0;
	cout<<"Point类的默认构造函数被调用"<<endl;
} 
Point::Point(int xx,int yy)
{
	x=xx;
	y=yy;
	cout<<"Point类的两个参数的构造函数被调用"<<endl; 
} 
Point::Point(const Point &p)
{
	x=p.x;
	y=p.y;
	cout<<"Point类的拷贝构造函数被调用"<<endl;
}
float Point::getX()
{
	return x;
}
float Point::getY()
{
	return y;
}
//Rectangle.h文件
#include "Point.h" 
#ifndef RECTANGLE_H
#define RECTANGLE_H
class Rectangle
{
	private:
		Point p1;
		Point p2;
	public:
		Rectangle();
		Rectangle(Point xp1,Point xp2);
		Rectangle(const Rectangle &rec);
		float computeArea();
};
#endif 
//Rectangle.cpp文件
#include <iostream>
#include "Rectangle.h"
#include <math.h> 
using namespace std;
Rectangle::Rectangle()
{
	cout<<"Rectangle类的默认构造函数被调用"<<endl;
}
Rectangle::Rectangle(Point xp1,Point xp2):p1(xp1),p2(xp2)
{
	cout<<"Rectangle类带有（Point,Point）的构造函数被调用"<<endl;
}
Rectangle::Rectangle(const Rectangle &rec):p1(rec.p1),p2(rec.p2)
{
	cout<<"Rectangle类的拷贝构造函数被调用"<<endl;
}
float Rectangle::computeArea()
{
	float length=fabs(p2.getX()-p1.getX());
	float width=fabs(p2.getY()-p1.getY());
	return length*width;
} 
//main.cpp文件
#include <iostream>
#include "Rectangle.h"
using namespace std;
int main() {
	Point p1;
	Point p2(10,20);
	Rectangle r1(p1,p2);
	cout<<"r1的面积为："<<r1.computeArea()<<endl;
	cout<<"========================"<<endl;
	Rectangle r2=r1;
	cout<<"r2的面积为："<<r2.computeArea()<<endl;
	return 0;
}
```

##### **图形：**

![image-20220916203538331](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed2/image-20220916203538331.png)

##### **运行结果：**

![image-20220916204648495](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed2/image-20220916204648495.png)

##### **分析输出结果：**

答：由题意可知Point类用于存储点坐标，并且Point在Rectangle类中定义的子对象用于进行矩形长宽计算，最后根据矩形面积计算，输出最后的矩形面积。

1、分析类的功能：
①在Point类：
定义了两个float的变量x，y
无参构造函数Point()；功能：初始化点坐标（x,y）=（0，0）
两个参数的构造函数Point(int xx,int yy);
拷贝构造函数Point(const Point &p);
获取x坐标函数float getX();
获取y坐标函数float getY(); 
②在Rectangle类：
类的组合，其中定义了p1，p2均为Point的子对象
无参构造函数Rectangle();
两个参数的构造函数Rectangle(Point xp1,Point xp2);
拷贝构造函数Rectangle(const Rectangle &rec);
面积计算函数：float computeArea();

2、查看函数的特点：
本题目的主要点在于类的组合里Rectangle类构造函数初始化列表的值传递，以及默认构造函数的调用时机、拷贝构造函数调用时机。

3、main函数中：
①Point p3; 这里只定义了p3对象，并没有赋值，在默认构造函数调用时机中，不指定类初始值时，会调用默认构造函数
显示输出：**Point类的默认构造函数被调用**
②Point p4(10,20); 很明显用Point类定义的p4对象赋值了，两个参数的构造函数Point(int xx,int yy);被调用
显示输出：**Point类的两个参数的构造函数被调用**
③以值传递的方式给函数参数传值的时候会调用拷贝构造函数：函数 Rectangle(Point xp1,Point xp2); 的参数是类Point 的对象，那么当 Rectangle(Point xp1,Point xp2); 被调用时，类 Point 的拷贝构造函数将被调用。换句话说，作为形参的对象，是用拷贝构造函数初始化的，而且调用拷贝构造函数时的参数，就是调用函数时所给的实参。
在Rectangle r1(p3,p4);，由于Point p3;调用过一次Point类的默认构造函数，将（x，y）=（0，0），所以当 Rectangle(Point xp1,Point xp2); 被调用时，调用拷贝构造函数时的参数，就是调用函数时所给的实参p3（0，0）,p4（10，20）。
显示输出：**Point类的拷贝构造函数被调用10,20**
由于

当我们提供了拷贝构造函数，系统就不会提供其他函数，所以在p3没有指定初始值的时候，不会调用默认构造函数，而是调用了拷贝构造函数。

```
Rectangle::Rectangle(Point xp1,Point xp2)
{
	p1=xp1;
	p2=xp2;
	cout<<"Rectangle类带有（Point,Point）的构造函数被调用"<<endl;
}
```

根据上述分析，主函数中“Whole(3)”;调用Whole类的有参构造函数。因为C++初始化类成员时，是按照声明的顺序初始化的，故会首先检查p1对象的值情况，由于p1对象为Part类的子对象，且未指定对象的初始值，即调用“Part();”的无参构造函数 
显示输出：**Part类的默认构造函数被调用**
此时3传入p2，因为p2对象为Part类的子对象，即“p2(3);”去先调用“Part (int x);”的有参构造函数 
显示输出：**Part类的一个参数的构造函数被调用,3**
此时在Whole::Whole(int i):p1(),p2(i){}中，p1，p2初始化完成，即可调用“Whole(int i);”的有参构造函数 
显示输出：**Whole类的构造函数被调用**
因为析构函数的调用时机一般都是编译器自动完成，不需要手动调用，且调用顺序是与构造函数调用顺序相反，故
显示输出：
**Whole类的析构函数被调用**
**Part类的析构函数被调用,3**
**Part类的析构函数被调用,0**
至于为什么最后一次调用“~Part();”val的值为0，是Part类中的无参构造函数“val=0;”