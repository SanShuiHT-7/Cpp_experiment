## 实验四  多态的应用

### 一、	实验目的

(1) 理解函数重载的机制,熟练掌握函数重载的方法。
(2) 理解运算符重载的机制,熟练掌握运算符重载的方法。
(3) 理解流插人与流提取运算符重载的机制,熟练掌握流插人与流提取运算符重载的方法。

### 二、	实验要求

(1) 掌握Visual C++开发环境的常用功能及使用，能在Visual C++开发环境下编程、调试程序(编辑、编译、连接、运行程序)。
(2) 按照实验内容编写相应功能的程序，记录完成步骤及结果。

### 三、	实验内容与步骤

#### 1.实验内容

(1) 分别计算int、double、float和long类型数组中的最小值，第一种方法：编写重载函数实现；第二种方法：使用函数模板或者类模板的成员函数实现。
(2) 设计程序实现复数的加法和乘法运算，要求使用两种方法实现：第一种方法：将加法运算符和乘法运算符重载为成员函数,使之能够实现复数的加法和乘法运算。第二种方法：将加法运算符和乘法运算符重载为友元函数, 使之能够实现复数的加法和乘法运算。
(3) 使用实验一中设计的Student类,其中至少包括四个数据成员，如果不足四个可补充新的数据成员，编程实现对插入符(<<)和提取符(>>)的重载,使它们能够对Student类的对象直接进行输人和输出，在主函数中进行测试。
(4) 在实验三对多本书完成增删改的基础上，应用函数重载、插入符(<<)的重载和提取符(>>)的重载进一步完善类的初始化和输出功能，并根据功能增加主菜单、二级菜单和清屏等功能提升用户体验。

#### 2.实验步骤

##### 1.1 sy4_多态的应用_1.1_重载函数

(1) 分别计算int、double、float和long类型数组中的最小值，第一种方法：编写重载函数实现；

###### **实现思路：**

通过题干设计计算一维数组中的最小值的算法

```C++
int min=a[0];
for(int i=1;i<n;i++)
{  
    if(min>a[i])
    {
        min=a[i];
    }
}
```

重载函数

```c++
int min(int a[], int n);
double min(double a[], int n);
float min(float a[], int n);
long min(long a[], int n);
```

完善重载函数体

```c++
int min(int a[], int n)
{
	int min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
		{
			min = a[i];
		}		
	}
	return min;
}
double min(double a[], int n)
{
	double min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
		{
			min = a[i];
		}
	}
	return min;
}
float min(float a[], int n)
{
	float min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
		{
			min = a[i];
		}
	}
	return min;
}
long min(long a[], int n)
{
	long min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
		{
			min = a[i];
		}
	}
	return min;
}
```

main中设计对应数组进行赋值

```c++
int a[7] = { 5,2,1,3,4,7,6 };
double b[7] = { 0.5,0.3,1.4,1.1,0.9,0.4,0.2 };
float c[7] = { 2.1f,2.3f,2.4f,1.5f,1.8f,1.3f,5.4f };
long d[7] = { 1,2,3,4,5,6,7 };
```

###### **整段代码：**

```c++
#include<iostream>
using namespace std;
int min(int a[], int n)
{
	int min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
		{
			min = a[i];
		}
			
	}
	return min;
}
double min(double a[], int n)
{
	double min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
		{
			min = a[i];
		}
	}
	return min;
}
float min(float a[], int n)
{
	float min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
		{
			min = a[i];
		}
	}
	return min;
}
long min(long a[], int n)
{
	long min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
		{
			min = a[i];
		}
	}
	return min;
}
int main()
{
	cout << "(1)函数重载:" << endl;
	int a[7] = { 5,2,1,3,4,7,6 };
	double b[7] = { 0.5,0.3,1.4,1.1,0.9,0.4,0.2 };
	float c[7] = { 2.1f,2.3f,2.4f,1.5f,1.8f,1.3f,5.4f };
	long d[7] = { 1,2,3,4,5,6,7 };
	cout << "int型数组最小值："<<min(a, 7) << endl;
	cout << "double型数组最小值：" << min(b, 7) << endl;
	cout << "float型数组最小值：" << min(c, 7) << endl;
	cout << "long型数组最小值：" << min(d, 7) << endl;
	return 0;
}
```

###### **运行结果：**

![image-20220927171015301](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed/image-20220927171015301.png)

##### 1.2 sy4_多态的应用_1.2_函数模板

(1) 分别计算int、double、float和long类型数组中的最小值，第二种方法：使用函数模板实现。

###### **实现思路：**

引入函数模板

```c++
template<typename T, typename T1>
T min(T a[], T1 n)
{
	T min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
        {
            min = a[i];
        }
	}
	return min;
}
```

调用函数模板：根据调用的情况，函数模板的实例化为模板函数过程是编译器自动完成的，和之前调用普通函数一样。

```c++
int a[7] = { 5,2,1,3,4,7,6 };
min(a, 7);
```



###### **整段代码：**

```c++
#include<iostream>
using namespace std;
template<typename T, typename T1>
T min(T a[], T1 n)
{
	T min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
			min = a[i];
	}
	return min;
}
int main()
{
	cout << "(2)函数模板:" << endl;
	int a[7] = { 5,2,1,3,4,7,6 };
	double b[7] = { 0.5,0.3,1.4,1.1,0.9,0.4,0.2 };
	float c[7] = { 2.1f,2.3f,2.4f,1.5f,1.8f,1.3f,5.4f };
	long d[7] = { 1,2,3,4,5,6,7 };
	cout << "int型数组最小值：" << min(a, 7) << endl;
	cout << "double型数组最小值：" << min(b, 7) << endl;
	cout << "float型数组最小值：" << min(c, 7) << endl;
	cout << "long型数组最小值：" << min(d, 7) << endl;
	return 0;
}
```

###### **运行结果：**

![image-20220927170756753](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed/image-20220927170756753.png)

##### 1.3 sy4_多态的应用_1.3_类模板

(1) 分别计算int、double、float和long类型数组中的最小值，第三种方法：使用类模板的成员函数实现。

###### **实现思路：**

引入类模板的形式构造Min类，以及成员函数T min(T a[], int n)，在class之前需要声明，这样才能知道T是定义类模板里面的数据类型

```c++
template<typename T>
class Min
{
public:
	T min(T a[], int n);
};
```

成员函数实现，把 Min<T> 看成整体

```c++
template<typename T>
T Min<T>::min(T a[], int n)
{
	T min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
			min = a[i];
	}
	return min;
}
```

模板类对象的创建：

原先的定义类对象的形式

```c++
Min a1;
```

而现在需要先手动生成一个模板类，再由这个模板类去定义对应的对象。即先Min<int>（Min就变成了int型的模板类），再Min<int> a1（a1就是int型的Min类所定义的对象），其他同理。

```c++
Min<int> a1;
Min<double> b1;
Min<float> c1;
Min<long> d1;
```



###### **整段代码：**

```c++
#include<iostream>
using namespace std;
template<typename T>
class Min
{
public:
	T min(T a[], int n);
};
template<typename T>
T Min<T>::min(T a[], int n)
{
	T min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
			min = a[i];
	}
	return min;
}
int main()
{
	cout << "(3)类模板:" << endl;
	int a[7] = { 5,2,1,3,4,7,6 };
	double b[7] = { 0.5,0.3,1.4,1.1,0.9,0.4,0.2 };
	float c[7] = { 2.1f,2.3f,2.4f,1.5f,1.8f,1.3f,5.4f };
	long d[7] = { 1,2,3,4,5,6,7 };
	Min<int> a1;
	cout << "int型数组最小值：" << a1.min(a,7) << endl;
	Min<double> b1;
	cout << "double型数组最小值：" << b1.min(b, 7) << endl;
	Min<float> c1;
	cout << "float型数组最小值：" << c1.min(c, 7) << endl;
	Min<long> d1;
	cout << "long型数组最小值：" << d1.min(d, 7) << endl;
	return 0;
}
```

###### **运行结果：**

![image-20220929165753359](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed/image-20220929165753359.png)

##### 2.1 sy4_多态的应用_2.1_运算符重载为成员函数

（2）设计程序实现复数的加法和乘法运算，要求使用两种方法实现：第一种方法：将加法运算符和乘法运算符重载为成员函数,使之能够实现复数的加法和乘法运算。

###### **实现思路：**

成员函数运算符的格式如下：

```c++
函数类型 operator 运算符名称(形参列表)
{
    对运算符的重载处理
}
```

 调用成员函数运算符的格式如下：

```c++
对象名.operator 运算符(参数)
它等价于
<对象名> 运算符 <参数>
例如：
a.operator+(b)等价于a+b
```

根据题意设计加法运算符和乘法运算符重载为成员函数,使之能够实现复数的加法和乘法运算。

```c++
Complex operator+(Complex c)
{
	Complex x;
	x.real = real + c.real;
	x.imag = imag + c.imag;
	return x;
}
Complex operator*(Complex c)
{
	Complex y;
	y.real = real * c.real - imag * c.imag;
	y.imag = real * c.imag + imag * c.real;
	return y;
}
```

在输出设计中，由于复数的形式分类，可分为实数，虚数，以及纯虚数，且嵌套逻辑比较简单，设计如下

```C++
if (imag != 0)//虚数a±bi
	{
		if (real != 0)//虚数a±bi
		{
			if (imag > 0)//虚数a+bi
			{
				cout << "虚数=" << real << "+" << imag << "i" << endl;
			}
			else//虚数a-bi
			{
				cout << "虚数=" << real << imag << "i" << endl;
			}
		}
		else//纯虚数bi
		{
			cout << "纯虚数=" << imag << "i" << endl;
		}
	}
	else//实数a
	{
		cout << "实数=" << real << endl;
	}
```

###### **整段代码：**

```c++
#include <iostream>
#include "math.h";
using namespace std;
class Complex
{
private:
	double real;
	double imag;
public:
	Complex();
	Complex(double r, double i);
	void display();
	Complex operator+(Complex c);
	Complex operator*(Complex c);

};
Complex::Complex()
{
	real = 0;
	imag = 0;
}
Complex::Complex(double r, double i)
{
	real = r;
	imag = i;
}
void Complex::display()
{
	if (imag != 0)//虚数a±bi
	{
		if (real != 0)//虚数a±bi
		{
			if (imag > 0)//虚数a+bi
			{
				cout << "虚数=" << real << "+" << imag << "i" << endl;
			}
			else//虚数a-bi
			{
				cout << "虚数=" << real << imag << "i" << endl;
			}
		}
		else//纯虚数bi
		{
			cout << "纯虚数=" << imag << "i" << endl;
		}
	}
	else//实数a
	{
		cout << "实数=" << real << endl;
	}

}
Complex Complex::operator+(Complex c)
{
	Complex x;
	x.real = real + c.real;
	x.imag = imag + c.imag;
	return x;
}
Complex Complex::operator*(Complex c)
{
	Complex y;
	y.real = real * c.real - imag * c.imag;
	y.imag = real * c.imag + imag * c.real;
	return y;
}
int main()
{
	Complex c1(5, 0), c2(0, 5), c3(5, 4), c4(3, -2);
	Complex S, P;
	cout << "c1为";
	c1.display();
	cout << "c2为";
	c2.display();
	cout << "c3为";
	c3.display();
	cout << "c4为";
	c4.display();
	cout << "c3+c4为";
	S = c3.operator+(c4);	//S = c3 + c4;
	S.display();
	cout << "c3*c4为";
	P = c3.operator*(c4);	//P = c3 + c4;
	P.display();
	return 0;
}
```

###### **运行结果：**

![image-20220927224750429](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed/image-20220927224750429.png)

##### 2.2 sy4_多态的应用_2.2_运算符重载为友元函数

（2）设计程序实现复数的加法和乘法运算，要求使用两种方法实现：第二种方法：将加法运算符和乘法运算符重载为友元函数, 使之能够实现复数的加法和乘法运算。

###### **实现思路：**

运算符重载为类的友元函数的一般格式为：

```c++
friend 函数类型 operator 运算符名称(形参列表)
{
    对运算符的重载处理
}
```

当运算符重载为类的友元函数时，由于没有隐含的this指针，因此操作数的个数没有变化，所有的操作数都必须通过函数的**形参**进行传递，函数的参数与操作数自左至右一一对应。

调用友元函数运算符的格式如下：

```c++
operator 运算符 (参数1,参数2)
  它等价于
  <参数1> 运算符 <参数2>
  例如： 
  operator+(a,b)等价于a+b
```

一般情况下，**单目运算符最好重载为类的成员函数，双目运算符则最好重载为类的友元函数**。

```c++
friend Complex operator+(const Complex &c1, const Complex &c2);
friend Complex operator*(const Complex &c1, const Complex &c2);
```

友元函数

```c++
Complex operator+(const Complex& c1, const Complex& c2)
{
	Complex x;
	x.real = c1.real + c2.real;
	x.imag = c1.imag + c2.imag;
	return x;
}
Complex operator*(const Complex& c1, const Complex& c2)
{
	Complex y;
	y.real = c1.real * c2.real - c1.imag * c2.imag;
	y.imag = c1.real * c2.imag + c1.imag * c2.real;
	return y;
}
```

###### **整段代码：**

```c++
#include <iostream>
#include "math.h";
using namespace std;
class Complex
{
private:
	double real;
	double imag;
public:
	Complex();
	Complex(double r, double i);
	void display();
	friend Complex operator+(const Complex &c1, const Complex &c2);
	friend Complex operator*(const Complex &c1, const Complex &c2);

};
Complex::Complex()
{
	real = 0;
	imag = 0;
}
Complex::Complex(double r, double i)
{
	real = r;
	imag = i;
}
void Complex::display()
{
	if (imag != 0)//虚数a±bi
	{
		if (real != 0)//虚数a±bi
		{
			if (imag > 0)//虚数a+bi
			{
				cout << "虚数=" << real << "+" << imag << "i" << endl;
			}
			else//虚数a-bi
			{
				cout << "虚数=" << real << imag << "i" << endl;
			}
		}
		else//纯虚数bi
		{
			cout << "纯虚数=" << imag << "i" << endl;
		}
	}
	else//实数a
	{
		cout << "实数=" << real << endl;
	}

}
Complex operator+(const Complex& c1, const Complex& c2)
{
	Complex x;
	x.real = c1.real + c2.real;
	x.imag = c1.imag + c2.imag;
	return x;
}
Complex operator*(const Complex& c1, const Complex& c2)
{
	Complex y;
	y.real = c1.real * c2.real - c1.imag * c2.imag;
	y.imag = c1.real * c2.imag + c1.imag * c2.real;
	return y;
}
int main()
{
	Complex c1(5, 0), c2(0, 5), c3(5, 4), c4(3, -2);
	Complex S, P;
	cout << "c1为";
	c1.display();
	cout << "c2为";
	c2.display();
	cout << "c3为";
	c3.display();
	cout << "c4为";
	c4.display();
	cout << "c3+c4为";
	S = operator+(c3,c4);	//S = c3 + c4;
	S.display();
	cout << "c3*c4为";
	P = operator*(c3,c4);	//P = c3 + c4;
	P.display();
	return 0;
}
```

###### **运行结果：**

![image-20220927231557586](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed/image-20220927231557586.png)

##### 3 sy4_多态的应用_3_输入输出运算符重载

(3) 使用实验一中设计的Student类,其中至少包括四个数据成员，如果不足四个可补充新的数据成员，编程实现对插入符(<<)和提取符(>>)的重载,使它们能够对Student类的对象直接进行输人和输出，在主函数中进行测试。

C++ 能够使用流提取运算符 >> 和流插入运算符 << 来输入和输出内置的数据类型。可以重载流提取运算符和流插入运算符来操作对象等用户自定义的数据类型。我们需要把运算符重载函数声明为类的友元函数，这样我们就能不用创建对象而直接调用函数。

###### **实现思路：**

运算符重载函数友元声明

```c++
friend istream& operator>>(istream&,Student&)
friend ostream& operator<<(ostream&,Student&)
```

输入、输出运算符重载函数的实现

```c++
istream& operator>>(istream &input, Student &stud)
{
    input >> stud.id >> stud.name >> stud.sex >> stud.score;
    return input;
}

```

```c++
ostream& operator<<(ostream &output, Student &stud)
{
	output << "学号:" << stud.id <<" " << " 姓名:" << stud.name << " " << "性别:" << stud.sex << " " << "成绩:" << stud.score << endl;;
	return output;
}
```

###### **整段代码：**

```c++
#include <iostream>
using namespace std;
class Student
{
private:
	string id;
	string name;
	string sex;
	float score;

public:

	friend istream& operator>>(istream &, Student &);
	friend ostream& operator<<(ostream &, Student &);
};
istream& operator>>(istream &input, Student &stud)
{
    input >> stud.id >> stud.name >> stud.sex >> stud.score;
    return input;
}
ostream& operator<<(ostream &output,  Student &stud)
{
	output << "学号:" << stud.id <<" " << " 姓名:" << stud.name << " " << "性别:" << stud.sex << " " << "成绩:" << stud.score << endl;;
	return output;
}
int main()
{
    Student stud1, stud2; 
    cout << "请输入学生学号、姓名、性别、分数信息：" << endl;;
    cin >> stud1;
    cout << "学生信息为："  << endl;
    cout << stud1;
    return 0;
}
```

###### **运行结果：**

![image-20220928125158147](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed/image-20220928125158147.png)

##### 4 sy4_多态的应用_4_Book

(4) 在实验三对多本书完成增删改的基础上，应用函数重载、插入符(<<)的重载和提取符(>>)的重载进一步完善类的初始化和输出功能，并根据功能增加主菜单、二级菜单和清屏等功能提升用户体验。

###### **实现思路：**

本实验主要对于输入输出部分进行修改，以及在原有的主菜单上添加二级菜单的相应功能和在使用过程中的清屏功能。

1、使用重载流插入运算符<<，实现cout对象直接输出一个Book对象的功能

（1）在类中添加流插入运算符<<函数的申明，并声明为友元函数friend类型

```C++
friend istream& operator>>(istream& input, Book& book);
```

（2）定义流插入运算符<<函数，把所有的输入整合到input里面最后return出

```c++
istream& operator>>(istream& input, Book& book)
{
	cout << "请输入书名：";
	input >> book.name;
	cout << "请输入图书价格：";
	//判断输入价格的合法性
	string num_price;
	unsigned long Bprice = 0;
	input >> book.price;
	while (cin.fail())
	{
		cin.clear();//首先调用 istream 类的成员函数 clear() 来清空错误标志
		input >> book.price;//通过 cin 和输入操作符 >> 将错误的输出保存在 string 类型的变量中，并且输出错误提示信息
		cout << "输入的" << num_price << "不是一个合理价格数，请重新输入一个数：";
		input >> book.price;
	}
	cout << "请输入图书ISBN：";
	input >> book.isbn;
	cout << "请输入图书的出版社：";
	input >> book.publisher;
	cout << "请输入作者：";
	input >> book.author;
	return input;
}
```

（3）主函数中只需要cin一个b1对象就行了

```c++
cin >> b1;//插入流重载
```

2、使用流插入运算符<<函数显示图书信息功能

（1）在类中添加流输出运算符>>函数的申明，并声明为友元函数friend类型

```c++
friend ostream& operator<<(ostream& output, Book& book);
```

（2）定义流输出运算符>>函数，把所有的输出整合到output，最后return出

```c++
ostream& operator<<(ostream& output, Book& book)
{
	output << left << setw(15) << book.name << setw(15) << book.price << setw(15) << book.isbn << setw(15) << book.publisher << setw(15) << book.author << endl;
	return output;
}
```

（3）原本的输出方式就可以直接通过输出流进行信息的输出，bookList[ ]是一个对象数组，bookList[i]其实就是Book类的对象，同上面b1的本质差别不大，这里也是把所有的信息整合到了一起。

```C++
void BookList::showBook(int i)
{
	cout << bookList[i];//使用输出流重载
}
```

3、添加子菜单功能，以及设计二级菜单

（1）将原有的菜单包含在函数体内

```c++
void Show_Menu()
{
	cout << "\n===========================\n";
	cout << "  <<欢迎使用图书管理系统>>  \n";
	cout << "===========================\n";
	cout << "[         主菜单          ]\n";
	cout << "===========================\n";
	cout << "【1.添加图书】【2.打印书库】\n\n";
	cout << "【3.查找图书】【4.删除图书】\n\n";
	cout << "【5.修改图书】【6.退出系统】\n";
	cout << "===========================\n";
	cout << "请输入对应功能序号:\n";
}
void Show_LowMenu_select()
{
	cout << "\n===========================\n";
	cout << "[         二级菜单        ]\n";
	cout << "===========================\n";
	cout << "1.[书名查询] 2.[价格查询]  \n\n";
	cout << "3.[ISBN查询] 4.[出版社查询]\n\n";
	cout << "5.[作者查询] 6.[序号查询]\n\n";
	cout << "7.[返回主菜单] \n";
	cout << "===========================\n";
	cout << "请输入对应功能序号:\n";
}
void Show_LowMenu_delect()
{
	cout << "\n===========================\n";
	cout << "[         二级菜单        ]\n";
	cout << "===========================\n";
	cout << "1.[书名删除] 2.[ISBN删除]  \n\n";
	cout << "3.[序号删除] 4.[返回主菜单]\n";
	cout << "===========================\n";
	cout << "请输入对应功能序号:\n";
}
void Show_LowMenu_update()
{
	cout << "\n===========================\n";
	cout << "[         二级菜单        ]\n";
	cout << "===========================\n";
	cout << "1.[修改书名] 2.[修改价格]  \n\n";
	cout << "3.[修改ISBN] 4.[修改出版社]\n\n";
	cout << "5.[修改作者] 6.[返回主菜单]\n";
	cout << "===========================\n";
	cout << "请输入对应功能序号:\n";
}

```

（2）暂使用嵌套switch的方式进行二级菜单的管理

```c++
while (1)
{
    case 1：
    {
        cout << "功能：1.【图书录入】" << endl;
    	break;
    }
       case 2：
    {
        cout << "功能：2.【打印图书】" << endl;
    	break;
    }
        case 3：
    {
        cout << "功能：3.【查找图书】" << endl;
    	break;
    }
        case 4：
    {
        cout << "功能：4.【删除图书】" << endl;
    	break;
    }
        case 5：
    {
        cout << "功能：5.【修改图书】" << endl;
    	break;
    }
    case 6:
    {
			cout << "已退出系统" << endl;
			exit(0);
	}
	int n = getchar();

```

（3）为了实现二级菜单和一级菜单之间的跳转引入goto语句

```c++
LOOP://起始位置
goto LOOP;//前往起始位置
```

（4.1）实现【图书录入】内容

在这一模块中，图书录入主要利用了上面所使用的插入流重载进行书本的信息录入，其中该模块的其他功能：
(4.1.1) system("cls");清屏功能，让用户界面更加简洁
(4.1.2) if判断，主要用途用于图书信息到insert函数写入的流程

```c++
case 1:
	{
		cout << "功能：1.【图书录入】" << endl;
		system("cls");
		cin >> b1;//插入流重载
		cout << "是否录入该图书（Y/N）:";
		cin >> flag_insert;
		if (((flag_insert == 'Y') || (flag_insert == 'y')))
		{
			list.insert(b1);
			system("cls");
			cout << "已经录入该书本" << endl;
			break;
		}
		else
		{
			system("cls");
			cout << "未录入" << endl;
			break;
		}
	}
```

（4.2）实现【打印图书】内容

 (4.2.1) 
 (4.2.2) list.showAll();输出流重载

```c++
case 2:
{
	cout << "功能：2.【打印书库】" << endl;
	system("cls");
	list.showAll();//输出流重载
	break;
}
```

（4.3）实现【查找图书】内容

由于查找的方式有多种，可以使用嵌套switch的方式实现二级菜单的功能
(4.3.1) 嵌套switch后Show_LowMenu_select();引入二级菜单
(4.3.2) system("cls");清屏功能，让用户界面更加简洁
(4.3.3) 功能大致都相同所以只需要知道一个怎么实现后面的也就同理了
	(4.3.3.1) cin >> book_name;//输入需要查找的书名
	(4.3.3.2) list.search_name(book_name);把book_name的参数传递到list对象的search_name函数中，去查找对应的第一本书的信息所对应的下标。
	(4.3.3.3) 将下标赋值给sel_1变量
	(4.3.3.4) 通过sel_1的变量去判断，因为如果书库里面有这本书，那么变量值是一定存在的，如果存在就输出图书信息，反之。
(4.3.4) goto LOOP;通过语句跳转到主菜单的位置，即可完成二级菜单的跳转

```c++
cout << "功能：3.【查找图书】" << endl;
system("cls");
while (1)
{
	Show_LowMenu_select();
	cin >> k;
	switch (k)
	{
		case 1:
		{
			system("cls");
			cout << "功能：1.[书名查找]" << endl;
			cout << "请输入需要查找的图书名：";
			cin >> book_name;
			int sel_1 = list.search_name(book_name);
			if (sel_1 >= 0)
			{
				system("cls");
				cout << "查询到以下图书：" << endl;
				list.showBook_title();
				list.showBook(sel_1);
			}
			else
			{
				system("cls");
				cout << "没有找到该图书信息" << endl;
			}
		break;
		}
		case 2:
		{
			system("cls");
			cout << "功能：2.[价格查找]" << endl;
			cout << "请输入需要查找的图书价格：";
			cin >> book_price;
			int sel_2 = list.search_price(book_price);
			if (sel_2 >= 0)
			{
				system("cls");
				cout << "查询到以下图书：" << endl;
				list.showBook_title();
				list.showBook(sel_2);
			}
			else
			{
				system("cls");
				cout << "没有找到该图书信息" << endl;
			}
		break;
		}
		case 3:
		{
            system("cls");
            cout << "功能：3.[ISBN查找]" << endl;
            cout << "请输入需要查找的ISBN：";
            cin >> book_isbn;
            int sel_3 = list.search_isbn(book_isbn);
            if (sel_3 >= 0)
            {
                system("cls");
                cout << "查询到以下图书：" << endl;
                list.showBook_title();
                list.showBook(sel_3);
            }
            else
            {
                system("cls");
                cout << "没有找到该图书信息" << endl;
            }
          break;
		}
        case 4:
        {
            system("cls");
            cout << "功能：4.[出版社查找]" << endl;
            cout << "请输入需要查找的出版社名：";
            cin >> book_publisher;
            int sel_4 = list.search_publisher(book_publisher);
            if (sel_4 >= 0)
            {
                system("cls");
                cout << "查询到以下图书：" << endl;
                list.showBook_title();
                list.showBook(sel_4);
            }
            else
            {
                system("cls");
                cout << "没有找到该图书信息" << endl;	
            }
        break;
        }
        case 5:
        {
            system("cls");
            cout << "功能：5.[作者查找]" << endl;
            cout << "请输入需要查找的作者名：";
            cin >> book_author;
            int sel_5 = list.search_author(book_author);
            if (sel_5 >= 0)
            {
                system("cls");
                cout << "查询到以下图书：" << endl;
                list.showBook_title();
                list.showBook(sel_5);
            }
            else
            {
                system("cls");
                cout << "没有找到该图书信息" << endl;
            }
        break;
        }
        case 6:
        {
            system("cls");
            cout << "功能：6.[序号查询]" << endl;
            cout << "请输入需要查找的图书序号：";
            int sel_6;
            cin >> sel_6;
            system("cls");
            cout << "查询到以下图书：" << endl;
            list.showBook(sel_6 - 1);
        break;
        }
        case 7:
        {
            system("cls");
            goto LOOP;
        }
        int n = getchar();
        }
	}
}
```

（4.4）实现【删除图书】内容

由于删除的方式有多种，可以使用嵌套switch的方式实现二级菜单的功能
(4.4.1) 嵌套switch后Show_LowMenu_delect();引入二级菜单
(4.4.2) system("cls");清屏功能，让用户界面更加简洁
(4.4.3) 功能大致都相同所以只需要知道一个怎么实现后面的也就同理了
	(4.4.3.1) cin >> book_name;//输入需要查找的书名
	(4.4.3.2) list.search_name(book_name);把book_name的参数传递到list对象的search_name函数中，去查找对应的第一本书的信息所对应的下标。
	(4.4.3.3) 将下标赋值给del_1变量
	(4.4.3.4) 通过del_1的变量去判断，因为如果书库里面有这本书，那么变量值是一定存在的，如果存在就输出图书信息，反之。
(4.4.4) 在序号删除时list.deleted(del_3 - 1);因为输入的时逻辑序号，而书库中对应的时物理序号。search_name();函数中返回的就是物理序号。故需要变量-1。
(4.4.5) goto LOOP;通过语句跳转到主菜单的位置，即可完成二级菜单的跳转

```c++
case 4:
{
    cout << "功能：4.【删除图书】" << endl;
    system("cls");
    while (1)
    {
        Show_LowMenu_delect();
        cin >> k;
        switch (k)
        {
        case 1:
        {
            system("cls");
            cout << "功能：1.[书名删除]" << endl;
            cout << "请输入需要删除的书名：";
            cin >> book_name;
            int del_1 = list.search_name(book_name);
            if (del_1 >= 0)
            {
                list.deleted(del_1);
                system("cls");
                cout << "图书已删除" << endl;
            }
            else
            {
                system("cls");
                cout << "没有找到该图书" << endl;
            }
        break;
        }
        case 2:
        {
            system("cls");
            cout << "功能：2.[ISBN删除]" << endl;
            cout << "请输入需要删除的ISBN：";
            cin >> book_isbn;
            int del_2 = list.search_isbn(book_isbn);
            if (del_2 >= 0)
            {
                list.deleted(del_2);
                system("cls");
                cout << "图书已删除" << endl;
            }
            else
            {
                system("cls");
                cout << "没有找到该图书" << endl;
            }
        break;
        }
        case 3:
        {
            system("cls");
            cout << "功能：3.[序号删除]" << endl;
            cout << "请输入需要删除的图书序号：";
            int del_3;
            cin >> del_3;
            list.deleted(del_3 - 1);
            system("cls");
            cout << "该图书已删除";
        break;
        }
        case 4:
        {
            system("cls");
            goto LOOP;
        }
        int n = getchar();
        }
    }
}
```

（4.5）实现【修改图书】内容

由于删除的方式有多种，可以使用嵌套switch的方式实现二级菜单的功能
(4.5.1) 嵌套switch后Show_LowMenu_update();引入二级菜单
(4.5.2) system("cls");清屏功能，让用户界面更加简洁
(4.5.3) 功能大致都相同所以只需要知道一个怎么实现后面的也就同理了
	(4.5.3.1) cin >> book_name;//输入需要查找的书名
	(4.5.3.2) list.search_name(book_name);把book_name的参数传递到list对象的search_name函数中，去查找对应的第一本书的信息所对应的下标。
	(4.5.3.3) 将下标赋值给upd_1变量
	(4.5.3.4) 通过upd_1的变量调用list.bookInfor(upd_1); bookInfor我们知道主要是用来获取书本信息的，我们通过search_name();获取到书本的物理下标，通过物理下标去获取整本书的信息，去传递到Book b的b对象中。
	(4.5.3.5) 很简单，如果有书那必然会实现if的成功操作，定义的new_bookname是用来存储我们的新信息空间。
	(4.5.3.6) b.setName(new_bookname);调用b对象的setName函数，将cin的new_bookname传入，进行书名的重新设置。
	(4.5.3.7) list.update(upd_1, b);有了图书的物理下标，有了修改后的图书信息，这样将这两个参数传递到update()中去覆盖原有的信息，这样就实现了信息的更新
(4.5.4) goto LOOP;通过语句跳转到主菜单的位置，即可完成二级菜单的跳转

```c++
case 5:
	{
		cout << "功能：5.【修改图书】" << endl;
		system("cls");
		while (1)
		{
			Show_LowMenu_update();
			cin >> k;
			switch (k)
			{
			case 1:
			{
				system("cls");
				cout << "功能：1.[修改书名]" << endl;
				cout << "请输入需要修改的图书名：";
				cin >> book_name;
				int upd_1 = list.search_name(book_name);//查找要修改的相应图书信息
				Book b = list.bookInfor(upd_1);//返回该本图书的信息
				if (upd_1 >= 0)
				{
					cout << "请输入该图书新的图书名：";
					cin >> new_bookname;
					b.setName(new_bookname);
					list.update(upd_1, b);
					system("cls");
					cout << "已修改，信息如下：" << endl;
					list.showBook_title();
					list.showBook(upd_1);
				}
				else
				{
					system("cls");
					cout << "没有找到该图书信息" << endl;
					}
			break;
			}
			case 2:
			{
				system("cls");
				cout << "功能：2.[修改价格]" << endl;
				cout << "请输入需要修改价格的图书ISBN：";//因为isbn能够确定是哪本书
				cin >> book_isbn;
				int upd_2 = list.search_isbn(book_isbn);//查找要修改的相应图书信息
				Book b = list.bookInfor(upd_2);//返回该本图书的信息
				if (upd_2 >= 0)
				{
					cout << "请输入该图书新的价格：";
					cin >> new_bookprice;
					b.setPrice(new_bookprice);
					list.update(upd_2, b);
					system("cls");
					cout << "已修改，信息如下：" << endl;
					list.showBook_title();
					list.showBook(upd_2);
				}
				else
				{
					system("cls");
					cout << "没有找到该图书信息" << endl;
				}
			break;
			}
			case 3:
			{
				system("cls");
				cout << "功能：3.[修改isbn]" << endl;
				cout << "请输入需要修改的ISBN：";//因为isbn能够确定是哪本书
				cin >> book_isbn;
				int upd_3 = list.search_isbn(book_isbn);//查找要修改的相应图书信息
				Book b = list.bookInfor(upd_3);//返回该本图书的信息
				if (upd_3 >= 0)
				{
					cout << "请输入该图书新的ISBN：";
					cin >> new_bookisbn;
					b.setIsbn(new_bookisbn);
					list.update(upd_3, b);
					system("cls");
					cout << "已修改，信息如下：" << endl;
					list.showBook_title();
					list.showBook(upd_3);
				}
				else
				{
					system("cls");
					cout << "没有找到该图书信息" << endl;
				}
			break;
			}
			case 4:
			{
				system("cls");
				cout << "功能：4.[修改出版社]" << endl;
				cout << "请输入需要修改出版社的图书ISBN：";//因为isbn能够确定是哪本书
				cin >> book_isbn;
				int upd_4 = list.search_isbn(book_isbn);//查找要修改的相应图书信息
				Book b = list.bookInfor(upd_4);//返回该本图书的信息
				if (upd_4 >= 0)
				{
					cout << "请输入该图书新的出版社名：";
					cin >> new_bookpublisher;
					b.setPublisher(new_bookpublisher);
					list.update(upd_4, b);
					system("cls");
					cout << "已修改，信息如下：" << endl;
					list.showBook_title();
					list.showBook(upd_4);
				}
				else
				{
					system("cls");
					cout << "没有找到该图书信息" << endl;
				}
			break;
			}
			case 5:
			{
				system("cls");
				cout << "功能：5.[修改作者]" << endl;
				cout << "请输入需要修改作者的图书ISBN：";//因为isbn能够确定是哪本书
				cin >> book_isbn;
				int upd_5 = list.search_isbn(book_isbn);//查找要修改的相应图书信息
				Book b = list.bookInfor(upd_5);//返回该本图书的信息
				if (upd_5 >= 0)
				{
					cout << "请输入该图书新的作者名：";
					cin >> new_bookauthor;
					b.setAuthor(new_bookauthor);
					list.update(upd_5, b);
					system("cls");
					cout << "已修改，信息如下：" << endl;
					list.showBook_title();
					list.showBook(upd_5);
				}
				else
				{
					system("cls");
					cout << "没有找到该图书信息" << endl;
				}
			break;
			}
			case 6:
			{
				system("cls");
				goto LOOP;
			}
			int n = getchar();
			}
		}
	}
```

（4.6）实现【退出系统】内容

```c++
case 6:
{
	system("cls");
	cout << "已退出系统" << endl;
	exit(0);
}
```

###### **整段代码：**

Book.h

```c++
#pragma once
#include <iostream>
#include <iomanip>
using namespace std;
#ifndef BOOK_H
#define BOOK_H
class Book {
private:
	string name;	 //图书名称 
	float price;	 //价格 
	string isbn;	 //ISBN 
	string publisher;//出版社 
	string author;	 //作者 
public:
	Book();//默认构造函数
	Book(string Bname, float Bprice, string Bisbn, string Bpuvlisher, string Bauthor);//重载构造函数
	string get_name();//获取书名
	void setName(const string newName);//设置书名
	float get_price();//获取价格
	void setPrice(const float newPrice);//设置价格
	string get_isbn();//获取ISBN
	void setIsbn(const string newIsbn);//设置ISBN
	string get_publisher();//获取出版社
	void setPublisher(const string newPublisher);//设置出版社
	string get_author();//获取作者
	void setAuthor(const string newAuthor);//设置作者
	friend istream& operator>>(istream& input, Book& book);//运算符重载方法，输入图书信息
	friend ostream& operator<<(ostream& output, Book& book);//运算符重载方法，输出图书信息
};
#endif // !BOOK_H
```

BookList.h

```c++
#pragma once
#include <iostream>
#include <iomanip>
#include "Book.h"
using namespace std;
#ifndef BOOKLIST_H
#define BOOKLIST_H
class BookList
{
private:
	Book bookList[100];
public:
	int bookNum;
	BookList();
	void insert(Book b);//增加一本书
	void showBook(int i);//打印下标为i的那本书的信息
	void showBook_title();//打印表头
	void showAll();//打印所有书
	int search_name(string name);//根据书名去查找对应的第一本书
	int search_price(float price);//根据价格去查找对应的第一本书
	int search_isbn(string isbn);//根据isbn去查找对应的第一本书
	int search_publisher(string publisher);//根据出版社去查找对应的第一本书
	int search_author(string author);//根据作者去查找对应的第一本书
	void update(int i, Book b);//修改时允许修改部分数据,这样就不需要修改所有的参数
	Book bookInfor(int i);//为了修改时获取原始数据，可以获取某一本书的具体信息，然后返回
	void deleted(int i);//删除第i本图书
};
#endif
```

Book.cpp

```c++
#include "Book.h"
Book::Book()//构造函数Book()
{
}

Book::Book(string Bname, float Bprice, string Bisbn, string Bpublisher, string Bauthor)//重载构造函数：形参初始化数据成员
{
	name = Bname;
	price = Bprice;
	isbn = Bisbn;
	publisher = Bpublisher;
	author = Bauthor;
}
string Book::get_name() {
	return name;
}
void Book::setName(const string newName) {
	name = newName;
}
float Book::get_price() {
	return price;
}
void Book::setPrice(const float newPrice) {
	price = newPrice;
}

string Book::get_isbn()
{
	return isbn;
}
void Book::setIsbn(const string newIsbn)
{
	isbn = newIsbn;
}
string Book::get_publisher()
{
	return publisher;
}
void Book::setPublisher(const string newPublisher)
{
	publisher = newPublisher;
}
string Book::get_author()
{
	return author;
}
void Book::setAuthor(const string newAuthor)
{
	author = newAuthor;
}
istream& operator>>(istream& input, Book& book)
{
	cout << "请输入书名：";
	input >> book.name;
	cout << "请输入图书价格：";
	input >> book.price;
	cout << "请输入图书ISBN：";
	input >> book.isbn;
	cout << "请输入图书的出版社：";
	input >> book.publisher;
	cout << "请输入作者：";
	input >> book.author;
	return input;
}
ostream& operator<<(ostream& output, Book& book)
{
	output << left << setw(15) << book.name << setw(15) << book.price << setw(15) << book.isbn << setw(15) << book.publisher << setw(15) << book.author << endl;
	return output;
}


```

BookList.cpp

```c++
#include "BookList.h"
BookList::BookList()
{
	bookNum = 0;
}
void BookList::insert(Book b)//创建图书
{
	bookList[bookNum].setName(b.get_name());//依次添加图书
	bookList[bookNum].setPrice(b.get_price());
	bookList[bookNum].setIsbn(b.get_isbn());
	bookList[bookNum].setPublisher(b.get_publisher());
	bookList[bookNum].setAuthor(b.get_author());
	bookNum++;//图书添加成功后，现有图书数目bookNum+1
}
void BookList::showBook(int i)//打印某一本书
{
	//cout << left << setw(15) << bookList[i].get_name() << setw(15) << bookList[i].get_price() << setw(15) << bookList[i].get_isbn() << setw(15) << bookList[i].get_publisher() << setw(15) << bookList[i].get_author() << endl;
	cout << bookList[i];//使用输出流重载
}
void BookList::showBook_title()//打印表头
{

	cout << left << setw(15) << "书名" << setw(15) << "价格" << setw(15) << "ISBN" << setw(15) << "出版社" << setw(15) << "作者" << endl;
}
void BookList::showAll()//打印所有书本
{
	int j;
	j = bookNum;
	if (j == 0)
	{
		cout << "本系统暂未存储图书" << endl;
	}
	else
	{
		cout << "共有 " << j << " 本图书存储系统中，" << "如下：" << endl;
		showBook_title();
	}

	for (bookNum = 0; bookNum < j; bookNum++)
	{
		showBook(bookNum);
	}
}//查找图书信息↓
int BookList::search_name(string Name)//书名查找
{
	int i;
	for (i = 0; i < bookNum; i++)
	{
		if (bookList[i].get_name() == Name)
			return i;
	}
	if (i == bookNum)
		return -1;
}
int BookList::search_price(float Price)//价格查找
{
	int i;
	for (i = 0; i < bookNum; i++)
	{
		if (bookList[i].get_price() == Price)
			return i;
	}
	if (i == bookNum)
		return -1;
}
int BookList::search_isbn(string Isbn)//isbn查找
{
	int i;
	for (i = 0; i < bookNum; i++)
	{
		if (bookList[i].get_isbn() == Isbn)
			return i;
	}
	if (i == bookNum)
		return -1;
}
int BookList::search_publisher(string Publisher)//出版社查找
{
	int i;
	for (i = 0; i < bookNum; i++)
	{
		if (bookList[i].get_publisher() == Publisher)
			return i;
	}
	if (i == bookNum)
		return -1;
}
int BookList::search_author(string Author)//作者查找
{
	int i;
	for (i = 0; i < bookNum; i++)
	{
		if (bookList[i].get_author() == Author)
			return i;
	}
	if (i == bookNum)
		return -1;
}
//查找图书信息↑
Book BookList::bookInfor(int i)//获取书本信息
{
	return bookList[i];
}
void BookList::update(int i, Book b)//修改图书信息，指定下标
{
	bookList[i].setName(b.get_name());//需要修改书的书名来自对象b输入的书名
	bookList[i].setPrice(b.get_price());
	bookList[i].setIsbn(b.get_isbn());
	bookList[i].setPublisher(b.get_publisher());
	bookList[i].setAuthor(b.get_author());
}
void BookList::deleted(int i)
{
	int j;
	for (j = i; j < (bookNum - 1); j++)
	{
		bookList[j].setName(bookList[j + 1].get_name());//删除后第j本书的新书名来自j+1本的书名，其他同理
		bookList[j].setPrice(bookList[j + 1].get_price());
		bookList[j].setIsbn(bookList[j + 1].get_isbn());
		bookList[j].setPublisher(bookList[j + 1].get_publisher());
		bookList[j].setAuthor(bookList[j + 1].get_author());
	}
	bookNum--;
}
```

main.cpp

```c++
#include <iostream>
#include <iomanip>
#include <conio.h>
#include <stdlib.h>
#include "Book.h"
#include "BookList.h"
using namespace std;
void Show_Menu()
{
	cout << "\n===========================\n";
	cout << "  <<欢迎使用图书管理系统>>  \n";
	cout << "===========================\n";
	cout << "[         主菜单          ]\n";
	cout << "===========================\n";
	cout << "【1.添加图书】【2.打印书库】\n\n";
	cout << "【3.查找图书】【4.删除图书】\n\n";
	cout << "【5.修改图书】【6.退出系统】\n";
	cout << "===========================\n";
	cout << "请输入对应功能序号:\n";
}
void Show_LowMenu_select()
{
	cout << "\n===========================\n";
	cout << "[         二级菜单        ]\n";
	cout << "===========================\n";
	cout << "1.[书名查询] 2.[价格查询]  \n\n";
	cout << "3.[ISBN查询] 4.[出版社查询]\n\n";
	cout << "5.[作者查询] 6.[序号查询]\n\n";
	cout << "7.[返回主菜单] \n";
	cout << "===========================\n";
	cout << "请输入对应功能序号:\n";
}
void Show_LowMenu_delect()
{
	cout << "\n===========================\n";
	cout << "[         二级菜单        ]\n";
	cout << "===========================\n";
	cout << "1.[书名删除] 2.[ISBN删除]  \n\n";
	cout << "3.[序号删除] 4.[返回主菜单]\n";
	cout << "===========================\n";
	cout << "请输入对应功能序号:\n";
}
void Show_LowMenu_update()
{
	cout << "\n===========================\n";
	cout << "[         二级菜单        ]\n";
	cout << "===========================\n";
	cout << "1.[修改书名] 2.[修改价格]  \n\n";
	cout << "3.[修改ISBN] 4.[修改出版社]\n\n";
	cout << "5.[修改作者] 6.[返回主菜单]\n";
	cout << "===========================\n";
	cout << "请输入对应功能序号:\n";
}

int main()
{
	string book_name, book_isbn, book_publisher, book_author;
	string new_bookname, new_bookisbn, new_bookpublisher, new_bookauthor;
	float book_price;
	float new_bookprice;
	Book b1;//初始化b1对象,书本
	BookList list;//初始化list对象，书本的各项信息
	char flag_insert = 'Y', flag_search = 'Y', flag_update = 'Y', flag_delete = 'Y';//设置flag值，用于控制循环
	int k;
	while (1)
	{

		//利用switch语句实现图书管理系统菜单

		LOOP:Show_Menu();
		cin >> k;
		switch (k)
		{
		case 1:
		{
			cout << "功能：1.【图书录入】" << endl;
			system("cls");
			cin >> b1;//插入流重载
			cout << "是否录入该图书（Y/N）:";
			cin >> flag_insert;
			if (((flag_insert == 'Y') || (flag_insert == 'y')))
			{
				list.insert(b1);
				system("cls");
				cout << "已经录入该书本" << endl;
				break;
			}
			else
			{
				system("cls");
				cout << "未录入" << endl;
				break;
			}
		}
		case 2:
		{
			cout << "功能：2.【打印书库】" << endl;
			system("cls");
			list.showAll();
			break;
		}
		case 3:
		{
			cout << "功能：3.【查找图书】" << endl;
			system("cls");
			while (1)
			{
				Show_LowMenu_select();
				cin >> k;
				switch (k)
				{
				case 1:
				{
					system("cls");
					cout << "功能：1.[书名查找]" << endl;
					cout << "请输入需要查找的图书名：";
					cin >> book_name;
					int sel_1 = list.search_name(book_name);
					if (sel_1 >= 0)
					{
						system("cls");
						cout << "查询到以下图书：" << endl;
						list.showBook_title();
						list.showBook(sel_1);
					}
					else
					{
						system("cls");
						cout << "没有找到该图书信息" << endl;
					}
					break;
				}
				case 2:
				{
					system("cls");
					cout << "功能：2.[价格查找]" << endl;
					cout << "请输入需要查找的图书价格：";
					cin >> book_price;
					int sel_2 = list.search_price(book_price);
					if (sel_2 >= 0)
					{

						system("cls");
						cout << "查询到以下图书：" << endl;
						list.showBook_title();
						list.showBook(sel_2);
					}
					else
					{

						system("cls");
						cout << "没有找到该图书信息" << endl;
					}
					break;
				}
				case 3:
				{
					system("cls");
					cout << "功能：3.[ISBN查找]" << endl;
					cout << "请输入需要查找的ISBN：";
					cin >> book_isbn;
					int sel_3 = list.search_isbn(book_isbn);
					if (sel_3 >= 0)
					{

						system("cls");
						cout << "查询到以下图书：" << endl;
						list.showBook_title();
						list.showBook(sel_3);
					}
					else
					{

						system("cls");
						cout << "没有找到该图书信息" << endl;
					}
					break;
				}
				case 4:
				{
					system("cls");
					cout << "功能：4.[出版社查找]" << endl;
					cout << "请输入需要查找的出版社名：";
					cin >> book_publisher;
					int sel_4 = list.search_publisher(book_publisher);
					if (sel_4 >= 0)
					{

						system("cls");
						cout << "查询到以下图书：" << endl;
						list.showBook_title();
						list.showBook(sel_4);
					}
					else
					{

						system("cls");
						cout << "没有找到该图书信息" << endl;
					}
					break;
				}
				case 5:
				{
					system("cls");
					cout << "功能：5.[作者查找]" << endl;
					cout << "请输入需要查找的作者名：";
					cin >> book_author;
					int sel_5 = list.search_author(book_author);
					if (sel_5 >= 0)
					{

						system("cls");
						cout << "查询到以下图书：" << endl;
						list.showBook_title();
						list.showBook(sel_5);
					}
					else
					{
						
						system("cls");
						cout << "没有找到该图书信息" << endl;
					}
					break;
				}
				case 6:
				{
					system("cls");
					cout << "功能：6.[序号查询]" << endl;
					cout << "请输入需要查找的图书序号：";
					int sel_6;
					cin >> sel_6;
					system("cls");
					cout << "查询到以下图书：" << endl;
					list.showBook(sel_6 - 1);
					break;
				}
				case 7:
				{
					system("cls");
					goto LOOP;

				}
				int n = getchar();
				}
			}

		}
		case 4:
		{
			cout << "功能：4.【删除图书】" << endl;
			system("cls");
			while (1)
			{
				Show_LowMenu_delect();
				cin >> k;
				switch (k)
				{
				case 1:
				{
					system("cls");
					cout << "功能：1.[书名删除]" << endl;
					cout << "请输入需要删除的书名：";
					cin >> book_name;
					int del_1 = list.search_name(book_name);
					if (del_1 >= 0)
					{
						list.deleted(del_1);
						system("cls");
						cout << "图书已删除" << endl;
					}
					else
					{
						system("cls");
						cout << "没有找到该图书" << endl;
					}
					break;
				}
				case 2:
				{
					system("cls");
					cout << "功能：2.[ISBN删除]" << endl;
					cout << "请输入需要删除的ISBN：";
					cin >> book_isbn;
					int del_2 = list.search_isbn(book_isbn);
					if (del_2 >= 0)
					{
						list.deleted(del_2);
						system("cls");
						cout << "图书已删除" << endl;
					}
					else
					{
						system("cls");
						cout << "没有找到该图书" << endl;
					}
					break;
				}
				case 3:
				{
					system("cls");
					cout << "功能：3.[序号删除]" << endl;
					cout << "请输入需要删除的图书序号：";
					int del_3;
					cin >> del_3;
					list.deleted(del_3 - 1);
					system("cls");
					cout << "该图书已删除";
					break;
				}
				case 4:
				{
					system("cls");
					goto LOOP;
				}
				int n = getchar();
				}
			}
		}
		case 5:
		{
			cout << "功能：5.【修改图书】" << endl;
			system("cls");
			while (1)
			{
				Show_LowMenu_update();
				cin >> k;
				switch (k)
				{
				case 1:
				{
					system("cls");
					cout << "功能：1.[修改书名]" << endl;
					cout << "请输入需要修改的图书名：";
					cin >> book_name;
					int upd_1 = list.search_name(book_name);//查找要修改的相应图书信息
					Book b = list.bookInfor(upd_1);//返回该本图书的信息
					if (upd_1 >= 0)
					{
						cout << "请输入该图书新的图书名：";
						cin >> new_bookname;
						b.setName(new_bookname);
						list.update(upd_1, b);
						system("cls");
						cout << "已修改，信息如下：" << endl;
						list.showBook_title();
						list.showBook(upd_1);
					}
					else
					{
						system("cls");
						cout << "没有找到该图书信息" << endl;
					}
					break;
				}
				case 2:
				{
					system("cls");
					cout << "功能：2.[修改价格]" << endl;
					cout << "请输入需要修改价格的图书ISBN：";//因为isbn能够确定是哪本书
					cin >> book_isbn;
					int upd_2 = list.search_isbn(book_isbn);//查找要修改的相应图书信息
					Book b = list.bookInfor(upd_2);//返回该本图书的信息
					if (upd_2 >= 0)
					{
						cout << "请输入该图书新的价格：";
						cin >> new_bookprice;
						b.setPrice(new_bookprice);
						list.update(upd_2, b);
						system("cls");
						cout << "已修改，信息如下：" << endl;
						list.showBook_title();
						list.showBook(upd_2);
					}
					else
					{
						system("cls");
						cout << "没有找到该图书信息" << endl;
					}
					break;
				}
				case 3:
				{
					system("cls");
					cout << "功能：3.[修改isbn]" << endl;
					cout << "请输入需要修改的ISBN：";//因为isbn能够确定是哪本书
					cin >> book_isbn;
					int upd_3 = list.search_isbn(book_isbn);//查找要修改的相应图书信息
					Book b = list.bookInfor(upd_3);//返回该本图书的信息
					if (upd_3 >= 0)
					{
						cout << "请输入该图书新的ISBN：";
						cin >> new_bookisbn;
						b.setIsbn(new_bookisbn);
						list.update(upd_3, b);
						system("cls");
						cout << "已修改，信息如下：" << endl;
						list.showBook_title();
						list.showBook(upd_3);
					}
					else
					{
						system("cls");
						cout << "没有找到该图书信息" << endl;
					}
					break;
				}
				case 4:
				{
					system("cls");
					cout << "功能：4.[修改出版社]" << endl;
					cout << "请输入需要修改出版社的图书ISBN：";//因为isbn能够确定是哪本书
					cin >> book_isbn;
					int upd_4 = list.search_isbn(book_isbn);//查找要修改的相应图书信息
					Book b = list.bookInfor(upd_4);//返回该本图书的信息
					if (upd_4 >= 0)
					{
						cout << "请输入该图书新的出版社名：";
						cin >> new_bookpublisher;
						b.setPublisher(new_bookpublisher);
						list.update(upd_4, b);
						system("cls");
						cout << "已修改，信息如下：" << endl;
						list.showBook_title();
						list.showBook(upd_4);
					}
					else
					{
						system("cls");
						cout << "没有找到该图书信息" << endl;
					}
					break;
				}
				case 5:
				{
					system("cls");
					cout << "功能：5.[修改作者]" << endl;
					cout << "请输入需要修改作者的图书ISBN：";//因为isbn能够确定是哪本书
					cin >> book_isbn;
					int upd_5 = list.search_isbn(book_isbn);//查找要修改的相应图书信息
					Book b = list.bookInfor(upd_5);//返回该本图书的信息
					if (upd_5 >= 0)
					{
						cout << "请输入该图书新的作者名：";
						cin >> new_bookauthor;
						b.setAuthor(new_bookauthor);
						list.update(upd_5, b);
						system("cls");
						cout << "已修改，信息如下：" << endl;
						list.showBook_title();
						list.showBook(upd_5);
					}
					else
					{
						system("cls");
						cout << "没有找到该图书信息" << endl;
					}
					break;
				}
				case 6:
				{
					system("cls");
					goto LOOP;
				}
				int n = getchar();
				}
			}

		}
		case 6:
		{
			system("cls");
			cout << "已退出系统" << endl;
			exit(0);
		}
		int n = getchar();
		}
	}
	return 0;
}
```

###### **测试用例：**

​	![image-20220929152241539](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed/image-20220929152241539.png)

###### **运行结果：**

![image-20220929152437443](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed/image-20220929152437443.png)

![image-20220929152538389](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed/image-20220929152538389.png)

![image-20220929152550540](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed/image-20220929152550540.png)

![image-20220929152602925](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed/image-20220929152602925.png)

![image-20220929152734213](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed/image-20220929152734213.png)

### 四、	实验总结

本次实验主要是函数模板，类模板，重载运算符的应用。
在函数模板中，我们通常是将具有类似功能的重载函数进行函数模板化，其中对象在调用函数模板中，系统会更具对象的数据类型去实例化对应的模板函数，从而达到对应调用。
在类模板中，需要先手动生成一个模板类，再由这个模板类去定义对应的对象，从而通过对象去调用相应得功能。
重载运算符本次实验主要进行了算数重载运算符和插入运算符和提取运算符的应用，在算符运算符中，了解了运算符重载函数的一般形式，其中在单目运算符中，运算符的操作数作为运算符重载函数的参数，运算符的运算结果对应着运算符重载函数的返回值。在双目运算符中，一般将双目运算符重载为全局的友元函数，执行运算符相当于调用相应的运算符函数。 “<<” : 左移运算符，因为被重载用于数据流的插入，所以又叫 插入运算符；“>>”: 右移运算符，因为被重载用于从数据流中提取数据，所以又叫提取运算符；C++ 能够使用流提取运算符 >> 和流插入运算符 << 来输入和输出内置的数据类型。可以重载流提取运算符和流插入运算符来操作对象等用户自定义的数据类型。我们需要把运算符重载函数声明为类的友元函数，这样我们就能不用创建对象而直接调用函数。
最后一点就是Book图书管理系统的完善了，本次实验加入了二级菜单以及上述知识点的应用，以及清屏功能，在功能的实现过程中，一步一步优化，加入的二级菜单利用LOOP能够实现主菜单与二级菜单之间的跳转，让系统的体验更加简单清晰。

