## 实验四  多态的应用

### 一、	实验目的

(1) 理解函数重载的机制,熟练掌握函数重载的方法。
(2) 理解运算符重载的机制,熟练掌握运算符重载的方法。
(3) 理解流插人与流提取运算符重载的机制,熟练掌握流插人与流提取运算符重载的方法。

### 二、	实验要求

(1) 掌握Visual C++开发环境的常用功能及使用，能在Visual C++开发环境下编程、调试程序(编辑、编译、连接、运行程序)。
(2) 按照实验内容编写相应功能的程序，记录完成步骤及结果。

### 三、	实验内容与步骤

#### 1.实验内容

(1) 分别计算int、double、float和long类型数组中的最小值，第一种方法：编写重载函数实现；第二种方法：使用函数模板或者类模板的成员函数实现。
(2) 设计程序实现复数的加法和乘法运算，要求使用两种方法实现：第一种方法：将加法运算符和乘法运算符重载为成员函数,使之能够实现复数的加法和乘法运算。第二种方法：将加法运算符和乘法运算符重载为友元函数, 使之能够实现复数的加法和乘法运算。
(3) 使用实验一中设计的Student类,其中至少包括四个数据成员，如果不足四个可补充新的数据成员，编程实现对插入符(<<)和提取符(>>)的重载,使它们能够对Student类的对象直接进行输人和输出，在主函数中进行测试。
(4) 在实验三对多本书完成增删改的基础上，应用函数重载、插入符(<<)的重载和提取符(>>)的重载进一步完善类的初始化和输出功能，并根据功能增加主菜单、二级菜单和清屏等功能提升用户体验。

#### 2.实验步骤

##### 1.1 sy4_多态的应用_1.2_重载函数

(1) 分别计算int、double、float和long类型数组中的最小值，第一种方法：编写重载函数实现；

###### **实现思路：**

通过题干设计计算一维数组中的最小值的算法

```C++
int min=a[0];
for(int i=1;i<n;i++)
{  
    if(min>a[i])
    {
        min=a[i];
    }
}
```

重载函数

```c++
int min(int a[], int n);
double min(double a[], int n);
float min(float a[], int n);
long min(long a[], int n);
```

完善重载函数体

```c++
int min(int a[], int n)
{
	int min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
		{
			min = a[i];
		}		
	}
	return min;
}
double min(double a[], int n)
{
	double min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
		{
			min = a[i];
		}
	}
	return min;
}
float min(float a[], int n)
{
	float min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
		{
			min = a[i];
		}
	}
	return min;
}
long min(long a[], int n)
{
	long min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
		{
			min = a[i];
		}
	}
	return min;
}
```

main中设计对应数组进行赋值

```c++
int a[7] = { 5,2,1,3,4,7,6 };
double b[7] = { 0.5,0.3,1.4,1.1,0.9,0.4,0.2 };
float c[7] = { 2.1f,2.3f,2.4f,1.5f,1.8f,1.3f,5.4f };
long d[7] = { 1,2,3,4,5,6,7 };
```

###### **整段代码：**

```c++
#include<iostream>
using namespace std;
int min(int a[], int n)
{
	int min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
		{
			min = a[i];
		}
			
	}
	return min;
}
double min(double a[], int n)
{
	double min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
		{
			min = a[i];
		}
	}
	return min;
}
float min(float a[], int n)
{
	float min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
		{
			min = a[i];
		}
	}
	return min;
}
long min(long a[], int n)
{
	long min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
		{
			min = a[i];
		}
	}
	return min;
}
int main()
{
	cout << "(1)函数重载:" << endl;
	int a[7] = { 5,2,1,3,4,7,6 };
	double b[7] = { 0.5,0.3,1.4,1.1,0.9,0.4,0.2 };
	float c[7] = { 2.1f,2.3f,2.4f,1.5f,1.8f,1.3f,5.4f };
	long d[7] = { 1,2,3,4,5,6,7 };
	cout << "int型数组最小值："<<min(a, 7) << endl;
	cout << "double型数组最小值：" << min(b, 7) << endl;
	cout << "float型数组最小值：" << min(c, 7) << endl;
	cout << "long型数组最小值：" << min(d, 7) << endl;
	return 0;
}
```

###### **运行结果：**

![image-20220927171015301](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed/image-20220927171015301.png)

##### 1.2 sy4_多态的应用_1.2_函数模板

(1) 分别计算int、double、float和long类型数组中的最小值，第二种方法：使用函数模板实现。

###### **实现思路：**

引入函数模板

```c++
template<typename T, typename T1>
T min(T a[], T1 n)
{
	T min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
        {
            min = a[i];
        }
	}
	return min;
}
```

调用函数模板：根据调用的情况，函数模板的实例化为模板函数过程是编译器自动完成的，和之前调用普通函数一样。

```c++
int a[7] = { 5,2,1,3,4,7,6 };
min(a, 7);
```



###### **整段代码：**

```c++
#include<iostream>
using namespace std;
template<typename T, typename T1>
T min(T a[], T1 n)
{
	T min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
			min = a[i];
	}
	return min;
}
int main()
{
	cout << "(2)函数模板:" << endl;
	int a[7] = { 5,2,1,3,4,7,6 };
	double b[7] = { 0.5,0.3,1.4,1.1,0.9,0.4,0.2 };
	float c[7] = { 2.1f,2.3f,2.4f,1.5f,1.8f,1.3f,5.4f };
	long d[7] = { 1,2,3,4,5,6,7 };
	cout << "int型数组最小值：" << min(a, 7) << endl;
	cout << "double型数组最小值：" << min(b, 7) << endl;
	cout << "float型数组最小值：" << min(c, 7) << endl;
	cout << "long型数组最小值：" << min(d, 7) << endl;
	return 0;
}
```

###### **运行结果：**

![image-20220927170756753](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed/image-20220927170756753.png)

##### 1.3 sy4_多态的应用_1.3_类模板

(1) 分别计算int、double、float和long类型数组中的最小值，第三种方法：使用类模板的成员函数实现。

###### **实现思路：**

引入类模板的形式构造Min类，以及成员函数T min(T a[], int n)，在class之前需要声明，这样才能知道T是定义类模板里面的数据类型

```c++
template<typename T>
class Min
{
public:
	T min(T a[], int n);
};
```

成员函数实现，把 Min<T> 看成整体

```c++
template<typename T>
T Min<T>::min(T a[], int n)
{
	T min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
			min = a[i];
	}
	return min;
}
```

模板类对象的创建：

原先的定义类对象的形式

```c++
Min a1;
```

而现在需要先手动生成一个模板类，再由这个模板类去定义对应的对象。即先Min<int>（Min就变成了int型的模板类），再Min<int> a1（a1就是int型的Min类所定义的对象），其他同理。

```c++
Min<int> a1;
Min<double> b1;
Min<float> c1;
Min<long> d1;
```



###### **整段代码：**

```c++
#include<iostream>
using namespace std;
template<typename T>
class Min
{
public:
	T min(T a[], int n);
};
template<typename T>
T Min<T>::min(T a[], int n)
{
	T min = a[0];
	for (int i = 1; i < n; i++)
	{
		if (min > a[i])
			min = a[i];
	}
	return min;
}
int main()
{
	cout << "(3)类模板:" << endl;
	int a[7] = { 5,2,1,3,4,7,6 };
	double b[7] = { 0.5,0.3,1.4,1.1,0.9,0.4,0.2 };
	float c[7] = { 2.1f,2.3f,2.4f,1.5f,1.8f,1.3f,5.4f };
	long d[7] = { 1,2,3,4,5,6,7 };
	Min<int> a1;
	cout << "int型数组最小值：" << a1.min(a,7) << endl;
	Min<double> b1;
	cout << "int型数组最小值：" << b1.min(b, 7) << endl;
	Min<float> c1;
	cout << "int型数组最小值：" << c1.min(c, 7) << endl;
	Min<long> d1;
	cout << "int型数组最小值：" << d1.min(d, 7) << endl;
	return 0;
}
```

###### **运行结果：**

![image-20220927173415482](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed/image-20220927173415482.png)

##### 2.1 sy4_多态的应用_2.1_运算符重载为成员函数

（2）设计程序实现复数的加法和乘法运算，要求使用两种方法实现：第一种方法：将加法运算符和乘法运算符重载为成员函数,使之能够实现复数的加法和乘法运算。

###### **实现思路：**

成员函数运算符的格式如下：

```c++
函数类型 operator 运算符名称(形参列表)
{
    对运算符的重载处理
}
```

 调用成员函数运算符的格式如下：

```c++
对象名.operator 运算符(参数)
它等价于
<对象名> 运算符 <参数>
例如：
a.operator+(b)等价于a+b
```

根据题意设计加法运算符和乘法运算符重载为成员函数,使之能够实现复数的加法和乘法运算。

```c++
Complex operator+(Complex c)
{
	Complex x;
	x.real = real + c.real;
	x.imag = imag + c.imag;
	return x;
}
Complex operator*(Complex c)
{
	Complex y;
	y.real = real * c.real - imag * c.imag;
	y.imag = real * c.imag + imag * c.real;
	return y;
}
```

在输出设计中，由于复数的形式分类，可分为实数，虚数，以及纯虚数，且嵌套逻辑比较简单，设计如下

```C++
if (imag != 0)//虚数a±bi
	{
		if (real != 0)//虚数a±bi
		{
			if (imag > 0)//虚数a+bi
			{
				cout << "虚数=" << real << "+" << imag << "i" << endl;
			}
			else//虚数a-bi
			{
				cout << "虚数=" << real << imag << "i" << endl;
			}
		}
		else//纯虚数bi
		{
			cout << "纯虚数=" << imag << "i" << endl;
		}
	}
	else//实数a
	{
		cout << "实数=" << real << endl;
	}
```

###### **整段代码：**

```c++
#include <iostream>
#include "math.h";
using namespace std;
class Complex
{
private:
	double real;
	double imag;
public:
	Complex();
	Complex(double r, double i);
	void display();
	Complex operator+(Complex c);
	Complex operator*(Complex c);

};
Complex::Complex()
{
	real = 0;
	imag = 0;
}
Complex::Complex(double r, double i)
{
	real = r;
	imag = i;
}
void Complex::display()
{
	if (imag != 0)//虚数a±bi
	{
		if (real != 0)//虚数a±bi
		{
			if (imag > 0)//虚数a+bi
			{
				cout << "虚数=" << real << "+" << imag << "i" << endl;
			}
			else//虚数a-bi
			{
				cout << "虚数=" << real << imag << "i" << endl;
			}
		}
		else//纯虚数bi
		{
			cout << "纯虚数=" << imag << "i" << endl;
		}
	}
	else//实数a
	{
		cout << "实数=" << real << endl;
	}

}
Complex Complex::operator+(Complex c)
{
	Complex x;
	x.real = real + c.real;
	x.imag = imag + c.imag;
	return x;
}
Complex Complex::operator*(Complex c)
{
	Complex y;
	y.real = real * c.real - imag * c.imag;
	y.imag = real * c.imag + imag * c.real;
	return y;
}
int main()
{
	Complex c1(5, 0), c2(0, 5), c3(5, 4), c4(3, -2);
	Complex S, P;
	cout << "c1为";
	c1.display();
	cout << "c2为";
	c2.display();
	cout << "c3为";
	c3.display();
	cout << "c4为";
	c4.display();
	cout << "c3+c4为";
	S = c3.operator+(c4);	//S = c3 + c4;
	S.display();
	cout << "c3*c4为";
	P = c3.operator*(c4);	//P = c3 + c4;
	P.display();
	return 0;
}
```

###### **运行结果：**

![image-20220927224750429](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed/image-20220927224750429.png)

##### 2.2 sy4_多态的应用_2.2_运算符重载为友元函数

（2）设计程序实现复数的加法和乘法运算，要求使用两种方法实现：第二种方法：将加法运算符和乘法运算符重载为友元函数, 使之能够实现复数的加法和乘法运算。

###### **实现思路：**

运算符重载为类的友元函数的一般格式为：

```c++
friend 函数类型 operator 运算符名称(形参列表)
{
    对运算符的重载处理
}
```

当运算符重载为类的友元函数时，由于没有隐含的this指针，因此操作数的个数没有变化，所有的操作数都必须通过函数的**形参**进行传递，函数的参数与操作数自左至右一一对应。

调用友元函数运算符的格式如下：

```c++
operator 运算符 (参数1,参数2)
  它等价于
  <参数1> 运算符 <参数2>
  例如： 
  operator+(a,b)等价于a+b
```

一般情况下，**单目运算符最好重载为类的成员函数，双目运算符则最好重载为类的友元函数**。

```c++
friend Complex operator+(const Complex &c1, const Complex &c2);
friend Complex operator*(const Complex &c1, const Complex &c2);
```

友元函数

```c++
Complex operator+(const Complex& c1, const Complex& c2)
{
	Complex x;
	x.real = c1.real + c2.real;
	x.imag = c1.imag + c2.imag;
	return x;
}
Complex operator*(const Complex& c1, const Complex& c2)
{
	Complex y;
	y.real = c1.real * c2.real - c1.imag * c2.imag;
	y.imag = c1.real * c2.imag + c1.imag * c2.real;
	return y;
}
```

###### **整段代码：**

```c++
#include <iostream>
#include "math.h";
using namespace std;
class Complex
{
private:
	double real;
	double imag;
public:
	Complex();
	Complex(double r, double i);
	void display();
	friend Complex operator+(const Complex &c1, const Complex &c2);
	friend Complex operator*(const Complex &c1, const Complex &c2);

};
Complex::Complex()
{
	real = 0;
	imag = 0;
}
Complex::Complex(double r, double i)
{
	real = r;
	imag = i;
}
void Complex::display()
{
	if (imag != 0)//虚数a±bi
	{
		if (real != 0)//虚数a±bi
		{
			if (imag > 0)//虚数a+bi
			{
				cout << "虚数=" << real << "+" << imag << "i" << endl;
			}
			else//虚数a-bi
			{
				cout << "虚数=" << real << imag << "i" << endl;
			}
		}
		else//纯虚数bi
		{
			cout << "纯虚数=" << imag << "i" << endl;
		}
	}
	else//实数a
	{
		cout << "实数=" << real << endl;
	}

}
Complex operator+(const Complex& c1, const Complex& c2)
{
	Complex x;
	x.real = c1.real + c2.real;
	x.imag = c1.imag + c2.imag;
	return x;
}
Complex operator*(const Complex& c1, const Complex& c2)
{
	Complex y;
	y.real = c1.real * c2.real - c1.imag * c2.imag;
	y.imag = c1.real * c2.imag + c1.imag * c2.real;
	return y;
}
int main()
{
	Complex c1(5, 0), c2(0, 5), c3(5, 4), c4(3, -2);
	Complex S, P;
	cout << "c1为";
	c1.display();
	cout << "c2为";
	c2.display();
	cout << "c3为";
	c3.display();
	cout << "c4为";
	c4.display();
	cout << "c3+c4为";
	S = operator+(c3,c4);	//S = c3 + c4;
	S.display();
	cout << "c3*c4为";
	P = operator*(c3,c4);	//P = c3 + c4;
	P.display();
	return 0;
}
```

###### **运行结果：**

![image-20220927231557586](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed/image-20220927231557586.png)

##### 3 sy4_多态的应用_3_输入输出运算符重载	

(3) 使用实验一中设计的Student类,其中至少包括四个数据成员，如果不足四个可补充新的数据成员，编程实现对插入符(<<)和提取符(>>)的重载,使它们能够对Student类的对象直接进行输人和输出，在主函数中进行测试。

C++ 能够使用流提取运算符 >> 和流插入运算符 << 来输入和输出内置的数据类型。可以重载流提取运算符和流插入运算符来操作对象等用户自定义的数据类型。我们需要把运算符重载函数声明为类的友元函数，这样我们就能不用创建对象而直接调用函数。

###### **实现思路：**

运算符重载函数友元声明

```c++
friend istream& operator>>(istream&,Student&)
friend ostream& operator<<(ostream&,Student&)
```

输入、输出运算符重载函数的实现

```c++
istream& operator>>(istream &input, Student &stud)
{
    input >> stud.id >> stud.name >> stud.sex >> stud.score;
    return input;
}

```

```c++
ostream& operator<<(ostream &output, Student &stud)
{
	output << "学号:" << stud.id <<" " << " 姓名:" << stud.name << " " << "性别:" << stud.sex << " " << "成绩:" << stud.score << endl;;
	return output;
}
```

###### **整段代码：**

```c++
#include <iostream>
using namespace std;
class Student
{
private:
	string id;
	string name;
	string sex;
	float score;

public:

	friend istream& operator>>(istream &, Student &);
	friend ostream& operator<<(ostream &, Student &);
};
istream& operator>>(istream &input, Student &stud)
{
    input >> stud.id >> stud.name >> stud.sex >> stud.score;
    return input;
}
ostream& operator<<(ostream &output,  Student &stud)
{
	output << "学号:" << stud.id <<" " << " 姓名:" << stud.name << " " << "性别:" << stud.sex << " " << "成绩:" << stud.score << endl;;
	return output;
}
int main()
{
    Student stud1, stud2; 
    cout << "请输入学生学号、姓名、性别、分数信息：" << endl;;
    cin >> stud1;
    cout << "学生信息为："  << endl;
    cout << stud1;
    return 0;
}
```

###### **运行结果：**

![image-20220928125158147](https://cdn.jsdelivr.net/gh/SanShuiHT-7/Typora-Figure-bed/image-20220928125158147.png)

##### 4 sy4_多态的应用_4_Book

(4) 在实验三对多本书完成增删改的基础上，应用函数重载、插入符(<<)的重载和提取符(>>)的重载进一步完善类的初始化和输出功能，并根据功能增加主菜单、二级菜单和清屏等功能提升用户体验。

###### **实现思路：**

首先利用输入流改造录入图书的方式

```C++
friend istream& operator>>(istream &,Book &)
```

```c++
istream& operator>>(istream &input,Book &book)
{
    cout << "请输入书名：";
	cin >> book_name;
	b1.setName(book_name);
	//判断输入价格的合法性
	cout << "请输入图书价格：";
	cin >> book_price;
	while (cin.fail())
	{
		cin.clear();//首先调用 istream 类的成员函数 clear() 来清空错误标志
		cin >> num_price;//通过 cin 和输入操作符 >> 将错误的输出保存在 string 类型的变量中，并且输出错误提示信息
		cout << "输入的" << num_price << "不是一个合理价格数，请重新输入一个数：";
		cin >> book_price;
	}
	b1.setPrice(book_price);
	cout << "请输入图书ISBN：";
	cin >> book_isbn;
	b1.setIsbn(book_isbn);
	cout << "请输入图书的出版社：";
	cin >> book_publisher;
	b1.setPublisher(book_publisher);
	cout << "请输入作者：";
	cin >> book_author;
	b1.setAuthor(book_author);
	cout << "是否录入该图书（Y/N）:";
	cin >> flag_insert;
}
```

利用输出流改造图书输出的方式

```c++
friend ostream& operator<<(ostream &,Book &)
```

```c++
friend ostream& operator<<(ostream &output,Book &book)
{
    
}
```



###### **整段代码：**



###### **运行结果：**



### 四、	实验总结